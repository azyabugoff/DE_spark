
# Лаба 03. Создание витрины данных из разных источников: файлы, NoSQL-хранилища, реляционные базы данных

## О витринах

_Витрина данных (англ. Data Mart; другие варианты перевода: хранилище данных специализированное, киоск данных, рынок данных) — срез хранилища данных, представляющий собой массив тематической, узконаправленной информации, ориентированный, например, на пользователей одной рабочей группы или департамента._ (Wikipedia)

## I. С высоты птичьего полета

У вас есть наборы данных в разных источниках:

* Cassandra – информация о клиентах: uid, пол и возраст.
* Elasticsearch – логи посещения интернет-магазина из экосистемы некоего технологического гиганта: страницы товаров, которые открывали посетители магазина, чтобы посмотреть товар или купить его.
* HDFS – информация о посещениях сторонних веб-сайтов пользователями, приобретенная у вендора: uid, набор (url, timestamp). 
* PostgreSQL - информация о тематических категориях веб-сайтов, приобретенная у вендора.

Вам надо аггрегировать данные из этих источников в витрину на основе PostgreSQL для отдела маркетинга, чтобы они могли делать свой анализ и таргетировать предложения для клиентов на основе их предпочтений в сети и в магазине.

![Alt text](images/img3.png?raw=true "Архитектура")

> postgres - 10.0.0.5:5432 (используйте персональную базу name_surname, ваш логин name_surname и пароль из ЛК)

> cassandra - 10.0.0.5:9042

> elasticsearch - 10.0.0.5:9200 (логин и пароль как от ЛК)

## II. Описание данных

### a. Информация о клиентах

Информация о клиентах хранится в Cassandra (keyspace `labdata`, table `clients`) в следующем виде:

* `uid` – уникальный идентификатор пользователя, string
* `gender` – пол пользователя, F или M - string
* `age` – возраст пользователя в годах, integer

### b. Логи посещения интернет-магазина

*Elasticsearch index: visits*

Из бэкенда интернет-магазина приходят отфильтрованные и обогащенные сообщения о просмотрах страниц товаров и покупках. Сообщения хранятся в Elasticsearch в формате json в следующем виде:

* `uid` – уникальный идентификатор пользователя, тот же, что и в базе с информацией о клиенте (в Cassandra), либо null, если в базе пользователей нет информации об этих посетителях магазина, string
* `event_type` – buy или view, соответственно покупка или просмотр товара, string
* `category` – категория товаров в магазине, string
* `item_id` – идентификатор товара, состоящий из категории и номера товара в категории, string
* `item_price` – цена товара, integer
* `timestamp` – unix epoch timestamp в миллисекундах

### c. Логи посещения веб-сайтов

`hdfs:///labs/laba03/weblogs.json`

Логи хранятся в формате json на HDFS и имеют следующую структуру:

* `uid` – уникальный идентификатор пользователя, тот же, что и в базе с информацией о клиенте (в Cassandra),
* массив `visits` c некоторым числом пар (timestamp, url), где `timestamp` – unix epoch timestamp в миллисекундах, `url` - строка.

В этом датасете не все записи содержат `uid`. Это означает, что были покупатели, еще пока не идетифицированные и не внесенные в базу данных клиентов. Покупки и просмотры таких покупателей можно игнорировать в этом задании.

### d. Информация о категориях веб-сайтов

Эта информация хранится в базе данных PostgreSQL `labdata` таблице `domain_cats`:

* `domain` (только второго уровня), string
* `category`, string 

Используйте ваш логин (нужно заменить в логине "." на "_") и пароль от ЛК для соединения с PostgreSQL.

## III. Задание 

Ознакомьтесь с памятками по [репозиторию](Github_Repo.md) и [PostgreSQL](PostgreSQL.md).

Используя psql, создайте в вашей базе данных `name_surname` таблицу `clients`  со следующими колонками:

uid, gender, age_cat, shop_cat1, ... , shop_catN, web_cat1, ... , web_catN

где:
* `uid` (primary key) – uid пользователя.
* `gender` – пол пользователя: `M`, `F`.
* `age_cat` – категория возраста, одна из пяти: `18-24`, `25-34`, `35-44`, `45-54`, `>=55`.
* `shop_cat`, `web_cat` – категории товаров и категории веб-сайтов.

Дайте пользователю `labchecker2` привилегию на `SELECT` из этой таблицы.
> При использовании overwrite при записи в таблицу Postgre, нужно давать гранты на чтение таблицы каждый раз после оверрайта таблицы.

Внимание! 

* Категории товаров берутся из логов посещения интернет-магазина. Чтобы сделать из категорий названия колонок, они приводятся к нижнему регистру, пробелы или тире заменяются на подчеркивание, к категории прибавляется приставка `shop_`. Например  `shop_everyday_jewelry`.

* Категории веб-сайтов берутся из датасета категорий вебсайтов, и точно также из них создаются имена колонок. Например: `web_arts_and_entertainment`.
* После вычленения домена из URL нужно удалить из доменов "www."

В колонках категорий товаров должно быть число посещений соответствующих страниц, а в колонках категорий веб-сайтов - число посещений соответствующих веб-сайтов.


## IV. Оформление работы

В вашем репо в подпапке lab03/data_mart положите sbt-project под названием data_mart с главным классом data_mart в файле data_mart.scala. либо сразу в корне папки data_mart, либо в data_mart/src/main/scala

Проект должен компилироваться и запускаться следующим образом:

```
cd lab03/data_mart
sbt package
spark-submit --class data_mart .target/scala-2.11/data_mart_2.11-1.0.jar 
```
> Для добавления коннекторов в spark-submit нужно указывать --packages, например spark-submit --packages org.elasticsearch:elasticsearch-spark-20_2.11:7.7.0

## V. Проверка

Чекер проверит:
* наличие файла с решением в репо, наличие .gitignore и его содержимое,
* наличие и структуру таблицы,
* число строк (пользователей) в таблице,
* число пользователей в каждой возрастной категории,
* некоторые записи, сравнив их с эталонными.

### Поля чекера

* `git_correct` = Тrue/False: в репо sb-spark существует `lab03/data_mart/data_mart.scala`.
* `info_git_errors` = "": ошибки при работе с репозиторием, если есть.
* `data_mart_table_correct` = Тrue/False: структура таблицы правильная, совпадают все колонки.
* `data_mart_number_of_users_correct` = Тrue/False: правильное чило пользователей в таблице.
* `data_mart_gender_age_cat_correct` = Тrue/False: правильное распределение пользователей по половозрастным категориям.
* `data_mart_user1_correct` = Тrue/False: для некоторого пользователя правильно указаны значения в колонках категорий.
* `info_data_mart_errors` = "": ошибки при работе с базой данных.
* `info_your_data` = {}: данные, полученные чекером через запросы в ваши таблицы.
* `lab_result` = True/False: зачет или нет (необходимо на всех проверяемых пунктах получить True).

## Справка по соединениям

* postgres - 10.0.0.5:5432 (используйте персональную базу name_surname, ваш логин name_surname и пароль из ЛК)
* cassandra - 10.0.0.5:9042
* elasticsearch - 10.0.0.5:9200
